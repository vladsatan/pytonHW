# Код с ошибкой

# def remove_duplicates_wrong(l: list[int]) -> list[int]:
#     d = {}
#     for i, v in enumerate(l):
#         if v in d:
#             if d[v] >= 1:
#                 l.pop(i)
#         else:
#             d[v] = 1

# Ошибка №1 заключается в том, что в варианте выше функция не возвращает измененный список 
# Ошибка №2 не была выполнена проверка по условию задания, что дуликати в кол-ве 2 штуки допускаются
# Не желательно использовать метод pop() во время цикла, так как может нарушиться индексация из-за изменения размера списка

# Ниже написал код, который работает правильно, создается новый список без многократных повторений, но при этом если 2 одинаковых числа, то цикл пропустит

def remove_duplicates_wrong(l: list[int]) -> list[int]:
    d = {}
    result = []
    for v in l:
        if v not in d:
            d[v] = 1
            result.append(v)
        elif d[v] < 2:  
            d[v] += 1
            result.append(v)
    return result


print(remove_duplicates_wrong([1, 1, 2, 3, 3, 3, 5, 5, 6]))